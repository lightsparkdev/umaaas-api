# coding: utf-8

"""
    UMA as a Service (UMAaaS) API

    API for managing global payments to and from UMA addresses.  This service facilitates cross-currency financial transactions using simple human-readable UMA addresses. 

    The version of the OpenAPI document: 2025-05-15
    Contact: support@lightspark.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from umaaas_api.models.currency_amount import CurrencyAmount
from typing import Optional, Set
from typing_extensions import Self

class UmaInvitation(BaseModel):
    """
    UmaInvitation
    """ # noqa: E501
    code: StrictStr = Field(description="The unique code of the invitation")
    created_at: datetime = Field(description="When the invitation was created", alias="createdAt")
    claimed_at: Optional[datetime] = Field(default=None, description="When the invitation was claimed if it has been claimed", alias="claimedAt")
    url: StrictStr = Field(description="The URL where this invitation can be claimed.")
    expires_at: Optional[datetime] = Field(default=None, description="When the invitation expires (if at all)", alias="expiresAt")
    inviter_uma: StrictStr = Field(description="The UMA address of the inviter", alias="inviterUma")
    invitee_uma: Optional[StrictStr] = Field(default=None, description="The UMA address of the invitee", alias="inviteeUma")
    status: StrictStr = Field(description="The status of the invitation")
    amount_to_send: Optional[CurrencyAmount] = Field(default=None, description="The amount to send to the invitee when the invitation is claimed. This is optional and if not provided, the invitee will not receive any amount. Note that the actual sending of the amount must be done by the inviter platform once the INVITATION_CLAIMED webhook is received. If the inviter platform either does not send the payment or the payment fails, the invitee will not receive this amount. This field is primarily used for display purposes on the claiming side of the invitation. This field is useful for \"send-by-link\" style user flows where an inviter can send a payment simply by sharing a link without knowing the receiver's UMA address. Note that these sends can only be sender-locked, meaning that the sender will not know ahead of time how much the receiver will receive in the receiving currency.", alias="amountToSend")
    __properties: ClassVar[List[str]] = ["code", "createdAt", "claimedAt", "url", "expiresAt", "inviterUma", "inviteeUma", "status", "amountToSend"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['PENDING', 'CLAIMED', 'EXPIRED', 'CANCELLED']):
            raise ValueError("must be one of enum values ('PENDING', 'CLAIMED', 'EXPIRED', 'CANCELLED')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UmaInvitation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """

        _dict = self.model_dump(
            mode="json",
            by_alias=True,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of amount_to_send
        if self.amount_to_send:
            _dict['amountToSend'] = self.amount_to_send.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UmaInvitation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "createdAt": obj.get("createdAt"),
            "claimedAt": obj.get("claimedAt"),
            "url": obj.get("url"),
            "expiresAt": obj.get("expiresAt"),
            "inviterUma": obj.get("inviterUma"),
            "inviteeUma": obj.get("inviteeUma"),
            "status": obj.get("status"),
            "amountToSend": CurrencyAmount.from_dict(obj["amountToSend"]) if obj.get("amountToSend") is not None else None
        })
        return _obj


