---
title: "Introduction"
---
import { umaaasProductName } from '/snippets/variables.mdx';
import PaymentFlow from '/snippets/payment-flow.mdx';

With {umaaasProductName}, you can send and receive low cost real-time payments to bank accounts and UMA addresses worldwide through a single, simple API. Lightspark Grid automatically routes each payment across its network of Grid switches, handling FX, blockchain settlement, and instant banking off-ramps for you.

- **Single API, global reach**: {umaaasProductName} interacts with the Money Grid to route your payments globally.
- **No crypto handling**: {umaaasProductName} converts between fiat and crypto for you on demand to simplify your implementation and minimize FX costs.
- **Real-time settlement**: Leverages local instant banking rails and global low latency crypto rails to settle payments in real-time.

<Note>For background on the UMA protocol itself, see the UMA Standard documentation: [UMA Standard—Introduction](https://docs.uma.me/uma-standard/introduction).</Note>

<PaymentFlow/>

## {umaaasProductName} Interfaces
- **API**: Programmatic access to create users, look up receivers, create quotes, fund payments, and reconcile via webhooks.
- **Dashboard**: Monitor payments and webhooks, manage API keys and environments, and troubleshoot with logs.
### Onboarding Customers
1. Create a user: `POST /users` with lightweight attributes (KYC/KYB handled by your regulated entity).
2. (Optional) Add external accounts: `POST /external-accounts` for bank account details when paying out to account numbers instead of UMAs.
3. Store each user’s UMA handle or relevant account identifier in your system.

<Note>You keep your brand/domain for UMAs (e.g., `$alice@yourapp.com`). See the UMA Standard for addressing details: [UMA—Introduction](https://docs.uma.me/uma-standard/introduction).</Note>
### Funding Payments
1. Create a quote: `POST /quotes` using the sender user ID or sender UMA as the source.
2. Use the returned `paymentInstructions` to fund in real time via supported rails (e.g., RTP, SEPA Instant, SPEI).
3. Track status via webhooks; on completion, reconcile user balances and mark the payment settled.

<Note>Quotes lock rates and include fees so the user can preview before committing.</Note>
### Sending & Receiving Payments
To send:
- If paying by UMA, resolve the receiver: `GET /receiver/uma/{uma}`.
- If paying by bank details, resolve the receiver: `GET /receiver/external-account/{accountId}` (create via `POST /external-accounts`).
- Preview: `POST /quotes` to fetch rate, fees, min/max, and funding instructions.
- Fund using one of the real-time `paymentInstructions` options returned by the quote.
- Handle webhooks to update the payment state (pending → completed/failed) and customer balances.

To receive:
- Provide your customer’s UMA; partners convert BTC ↔ local fiat and settle to your specified rails.
- Webhooks notify you of incoming payments so you can credit the receiver.
### Environments
Use separate keys and base URLs for Sandbox and Production. See:
- Authentication: `/api-reference/authentication`
- Environments: `/api-reference/environments`

<Note>Sandbox simulates real-time flows so you can build and test end-to-end without moving funds.</Note>
### Dashboard
Use the dashboard to:
- Inspect quotes, transactions, and webhook delivery attempts.
- Retry failed webhook deliveries and download logs for troubleshooting.
- Manage API keys and environment access.
